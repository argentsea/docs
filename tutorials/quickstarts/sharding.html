<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>QuickStart Two | ArgentSea Docs </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="QuickStart Two | ArgentSea Docs ">
    <meta name="generator" content="docfx 2.40.0.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="http://www.argentsea.com">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="quickstart-two">QuickStart Two</h1>

<p>The <a href="configuration.html">previous QuickStart</a> introduced configuration and mapping. This tutorial extends that information while working with a sharded data set. This tutorial also extends the mapping functionality to include list and object properties on the model class.</p>
<p>Sharded data introduces two complexities:</p>
<ul>
<li>How do I uniquely identify and locate a record, which could be on any shard?</li>
<li>How do I manage data on one shard and related data on a foreign shard?</li>
</ul>
<p>This walkthrough illustrates how both challenges can be met.</p>
<h2 id="create-the-project">Create the Project</h2>
<p>If you are following along at home with a new project, in Visual Studio create a new “ASP.NET Core Web Application” project. When prompted, select the “API” project type. Once the solution is created, open your dependencies and add the following NuGet packages:</p>
<ul>
<li><strong>ArgentSea.Sql</strong> or <strong>ArgentSea.Pg</strong> - for SQL Sever or PostgreSQL databases respectively</li>
<li><strong>Swashbuckle.Aspnetcore</strong> - for <a href="https://swagger.io/">Swagger</a> and for invoking the API without creating a client</li>
</ul>
<p>To follow a standard convention for an MVC project, create folders for <strong>Models</strong>, <strong>InputModels</strong>, and <strong>Stores</strong> (or “Repositories” if you prefer).</p>
<h2 id="the-sample-data">The Sample Data</h2>
<p>Whether you simply downloaded the walkthrough or a creating a new project, you will need to create some sample shards.</p>
<p>Our sample application is going to track <strong>Customers</strong>. The data set is completely made-up and not especially realistic. <strong>Customers</strong> can have multiple <strong>Locations</strong> (1:∞). <strong>Customers</strong> can also have <strong>Contacts</strong>, but the <strong>Contacts</strong> can belong to more than one <strong>Customer</strong> (∞:∞). The <strong>Contact</strong> may not exist in the same shard as the <strong>Customer</strong>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The data is set up this way to illustrate one of the difficulties with sharded data: managing relationships between records that exist on different shards. In this case, a <strong>Customer</strong> may be associated with a Contact on any shard. Managing this — an managing this efficiently — adds substantial complexity.</p>
</div>
<p>In our sample model, the ∞:∞ relationship between a <strong>Contact</strong> and a <strong>Customer</strong> is managed by a linking table, <strong>CustomerContacts</strong>. Given the id of a local <strong>Customer</strong>, the table lists the keys of the associated <strong>Contacts</strong>. What happens if instead I have the id of a <strong>Contact</strong> and want to find all of the <strong>Customers</strong>? With only that table, it would be necessary to query <em>every shard</em> to determine whether they have a related <strong>Customer</strong>!</p>
<p>To better optimize this, the data model creates a second <strong>ContactCustomers</strong> linking table. With this approach, if I have a <strong>Contact</strong> and want to find <strong>Customers</strong> (including those in foreign shards), or <strong>Customers</strong> and want to find <strong>Contacts</strong> (again, even those not local), I can use the appropriate linking table and query only the shards with relevant records data. The downside is that when the <strong>Customer</strong> and <strong>Contact</strong> are on different shards, this relationship must be managed in different tables on different databases.</p>
<p>In a real implementation, it might be beneficial to include additional information in the linking tables, like including the contact name within the <strong>CustomerContact</strong> table for example, so that common lookups do not require secondary lookups from related shards just to get the contact name. The QuickStart example doesn’t do this so that it can illustrate performing these secondary lookups.</p>
<p>Naturally, deleting a <strong>Customer</strong> means removing the <strong>ContactCustomers</strong> link from each Contact also, which could be on any shard. This shard list must be retrieved from the <strong>CustomerContacts</strong> list before it is deleted. Updating a Customer’s <strong>Contacts</strong> could also impact multiple shards in two ways: a removed foreign-shard <strong>Contact</strong> must be deleted and a additional foreign-shard <strong>Contacts</strong> must be added.</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q_tabid-sql" role="tab" aria-controls="tabpanel_CeZOj-G++Q_tabid-sql" data-tab="tabid-sql" tabindex="0" aria-selected="true">SQL Server</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q_tabid-pg" role="tab" aria-controls="tabpanel_CeZOj-G++Q_tabid-pg" data-tab="tabid-pg" tabindex="-1">PostgreSQL</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q_tabid-sql" role="tabpanel" data-tab="tabid-sql">

<p>The SQL for the sample data is found in the GitHub source repository, at <a href="https://github.com/argentsea/quickstarts/tree/master/QuickStart2.Sql/QuickStart2.Sql/SqlSetup">https://github.com/argentsea/quickstarts/tree/master/QuickStart2.Sql/QuickStart2.Sql/SqlSetup</a>.</p>
<p>The first SQL script to execute is <em>ServerSetup.sql</em>, which creates four databases and two logins.</p>
<div class="CAUTION">
<h5>Caution</h5>
<p>The logins contain weak passwords (that are published on the Internet), so you might consider changing them; on the other hand, these will only have permission to execute procedures or functions in a specific namespace, so it’s not a big risk.</p>
</div>
<div class="NOTE">
<h5>Note</h5>
<p>Conceptually, these four databases would correspond to regional data stores in the <em>United States</em>, <em>Brazil</em>, <em>Europe</em>, and <em>China</em>. In my real global application I would replicate the data from each region to each other region. Therefore, each region would have one writable data store and three readable ones. In this way, the “local” shard is writeable, the “foreign” shards are read-only. Writes to a foreign shard must be done across the WAN. Your implementation may vary.<br>
Our walkthrough, however, only needs four simple databases on one server. We’ll only imagine the rest.</p>
</div>
<p>Next, after the databases have been created, <em>connect to each database in turn</em> and run the <em>ShardSetup.sql</em> SQL script. This will created the schemas, tables, stored procedures, reference data, etc. for our sample databases.</p>
<p>Finally, run the shard-specific SQL scripts — <em>ShardUS.sql</em>, <em>ShardBR.sql</em>, <em>ShardUS.sql</em>, <em>ShardUS.sql</em> — within their respective databases. This will load the shard-specific sample data.</p>
</section>
<section id="tabpanel_CeZOj-G++Q_tabid-pg" role="tabpanel" data-tab="tabid-pg" aria-hidden="true" hidden="hidden">

<p>The SQL for the sample data is found in the GitHub source repository, at <a href="https://github.com/argentsea/quickstarts/tree/master/QuickStart2.Pg/QuickStart2.Pg/SqlSetup">https://github.com/argentsea/quickstarts/tree/master/QuickStart2.Pg/QuickStart2.Pg/SqlSetup</a>.</p>
<p>Create four PostgreSQL databases:</p>
<ul>
<li>customershard_br</li>
<li>customershard_eu</li>
<li>customershard_us</li>
<li>customershard_zh</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>Conceptually, these four databases would correspond to regional data stores in the <em>United States</em>, <em>Brazil</em>, <em>Europe</em>, and <em>China</em>. In my real global application I would replicate the data from each region to each other region. Therefore, each region would have one writable data store and three readable ones. In this way, the “local” shard is writeable, the “foreign” shards are read-only. Writes to a foreign shard must be done across the WAN. Your implementation may vary.<br>
Our walkthrough, however, only needs four simple databases on one server. We’ll only imagine the rest.</p>
</div>
<p>After the databases have been created, <em>connect to each database in turn</em> and run the <em>ShardSetup.sql</em> SQL script. This will create the schemas, tables, stored procedures, reference data, etc. for our sample databases.</p>
<div class="CAUTION">
<h5>Caution</h5>
<p>The database setup create users with weak passwords (that are also published on the Internet), so you might consider changing them.</p>
</div>
<p>Finally, run the shard-specific SQL scripts — <em>ShardUS.sql</em>, <em>ShardBR.sql</em>, <em>ShardUS.sql</em>, <em>ShardUS.sql</em> — within their respective databases. This will load the shard-specific sample data.</p>
</section>
</div>

<p>At this point, we should have four database with identical table structures. SQL Server instances should also have a identical set of stored procedures.</p>
<h2 id="the-shardid">The ShardId</h2>
<p>Each of the four databases needs an identifier. This is more significant than it sounds. ArgentSea uses a “virtual compound key” consisting of the ShardId and the RecordId; this is called a <a href="/api/ArgentSea.ShardKey-2.html">ShardKey</a>. A thorough discussion of the options and impact is <a href="/tutorials/sharding/shardkey.md">here</a>. The précis is that once established, the type (and values) of the <em>ShardId</em> cannot be easily changed. The ShardId is a part of record identification, so confusion or misconfiguration could result in data corruption.</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-1_tabid-sql" role="tab" aria-controls="tabpanel_CeZOj-G++Q-1_tabid-sql" data-tab="tabid-sql" tabindex="0" aria-selected="true">SQL Server</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-1_tabid-pg" role="tab" aria-controls="tabpanel_CeZOj-G++Q-1_tabid-pg" data-tab="tabid-pg" tabindex="-1">PostgreSQL</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-1_tabid-sql" role="tabpanel" data-tab="tabid-sql">

<p>In this sample application, the type of the ShardId for SQL Server is a <code>byte</code> (SQL TinyInt). Because ArgentSea uses a generic type to define the ShardId, you can use one of many types in your application; however, the ShardId must be consistent throughout the application.</p>
<p>Naturally, this mandates an upper maximum  of 256 shards. If there is any possibility of one day needing to exceeding this count, you can use a <code>short</code> data type instead.</p>
</section>
<section id="tabpanel_CeZOj-G++Q-1_tabid-pg" role="tabpanel" data-tab="tabid-pg" aria-hidden="true" hidden="hidden">

<p>In this sample application, the type of the ShardId for PostgreSQL is a <code>short</code> (SQL SmallInt). Because ArgentSea uses a generic type to define the ShardId, you can use one of many types in your application; however, the ShardId must be consistent throughout the application.</p>
</section>
</div>
<h2 id="configuring-connections">Configuring Connections</h2>
<p>Because sharded data may require a large number of data connections, ArgentSea offers a more flexible way of managing this than by using connection strings. ArgentSea offers the “Hereditary Configuration Hierarchy”. This allows you to set an attribute at the parent level and all children will inherit this value, unless overwritten by a child. A more thorough discussion is <a href="/tutorials/configuration/hierarchy.md">here</a>.</p>
<p>In our sample application, we can use the same server or host for all connections; each shard connection only changes the database name. (In a production deployment, the configuration might be exactly backwards: the databases have identical names, but each is on a different host). We also want to use the <em>webWriter</em> user for write connections and <em>webReader</em> for read connections.</p>
<p>So the configuration settings looks like this (with annotations):</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-2">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-2_tabid-sql" role="tab" aria-controls="tabpanel_CeZOj-G++Q-2_tabid-sql" data-tab="tabid-sql" tabindex="0" aria-selected="true">SQL Server</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-2_tabid-pg" role="tab" aria-controls="tabpanel_CeZOj-G++Q-2_tabid-pg" data-tab="tabid-pg" tabindex="-1">PostgreSQL</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-2_tabid-sql" role="tabpanel" data-tab="tabid-sql">

<pre><code class="lang-json">{
  &quot;SqlShardSets&quot;: [¹
    {
      &quot;ShardSetName&quot;: &quot;Customers&quot;,²
      &quot;DataSource&quot;: &quot;.&quot;,³
      &quot;DefaultShardId&quot;: 1,⁴
      &quot;Write&quot;: {⁵
        &quot;UserName&quot;: &quot;webWriter&quot;,
        &quot;Password&quot;: &quot;Pwd567890&quot;,
      },
      &quot;Read&quot;: {⁵
        &quot;ApplicationIntent&quot;: &quot;ReadOnly&quot;,
        &quot;UserName&quot;: &quot;webReader&quot;,
        &quot;Password&quot;: &quot;Pwd123456&quot;
      },
      &quot;Shards&quot;: [⁶
        {
          &quot;ShardId&quot;: 1,⁷
          &quot;InitialCatalog&quot;: &quot;CustomerShardUS&quot;⁸
        },
        {
          &quot;ShardId&quot;: 2,⁷
          &quot;InitialCatalog&quot;: &quot;CustomerShardEU&quot;⁸
        },
        {
          &quot;ShardId&quot;: 3,⁷
          &quot;InitialCatalog&quot;: &quot;CustomerShardBR&quot;⁸
        },
        {
          &quot;ShardId&quot;: 4,⁷
          &quot;InitialCatalog&quot;: &quot;CustomerShardZH&quot;⁸
        }
      ]
    }
  ]
}
</code></pre>
<h3 id="annotations">Annotations</h3>
<p>¹ <code>SqlShardSets</code> is the root JSON section for all the shard configuration metadata. It contains an array of shard sets.</p>
<p>² <code>ShardSetName</code> is a <em>required</em> key for this specific shard set. Multiple shard sets are possible and each will be identified by this key. This value must exactly match the value used in your code to invoke this shard set.</p>
<p>³ <code>DataSourceName</code> is a connection attribute. Connection attributes can appear anywhere in the hierarchy. Because it appears at the “shard set” level, all shards in the shard set will inherit this server name.</p>
<p>⁴ <code>DefaultShardId</code> this setting determins which shard is presented as the <code>ShardSet.DefaultShard</code>. This is useful for determining which shard should be actively accepting new records for this client.</p>
<p>⁵ <code>Read</code> and <code>Write</code> are peculiar, and optional, members of shard set’s “inheritance” chain, as their children are indirect. Any attributes defined in the shard set’s <code>Write</code> section apply only to write connections. Likewise, for <code>Read</code> connections. These values can be overwritten by shard or connection attributes.</p>
<p>⁶ <code>Shards</code> is an array of shard connections, one for each shard in the shard set.</p>
<p>⁷ <code>ShardId</code> is a <em>required</em> identifier for the shard. This value is essential for finding and identifying a sharded record. It cannot be duplicated within a shard set. If the type of the ShardId is a string, then this value should have quotes around it in the JSON file.</p>
<p>⁸ <code>InitialCatalog</code> is a connection attribute. Because it appears at the shard level, both read connections and write connections for this shard will inherit this value.</p>
</section>
<section id="tabpanel_CeZOj-G++Q-2_tabid-pg" role="tabpanel" data-tab="tabid-pg" aria-hidden="true" hidden="hidden">

<pre><code class="lang-json">{
  &quot;PgShardSets&quot;: [¹
    {
      &quot;ShardSetName&quot;: &quot;Customers&quot;,²
      &quot;DefaultShardId&quot;: 1,⁴
      &quot;Host&quot;: &quot;localhost&quot;,³
      &quot;Write&quot;: {⁵
        &quot;UserName&quot;: &quot;webWriter&quot;,
        &quot;Password&quot;: &quot;Pwd567890&quot;
      },
      &quot;Read&quot;: {⁵
        &quot;UserName&quot;: &quot;webReader&quot;,
        &quot;Password&quot;: &quot;Pwd123456&quot;
      },
      &quot;Shards&quot;: [⁶
        {
          &quot;ShardId&quot;: 1,⁷
          &quot;Database&quot;: &quot;CustomerShardUS&quot;⁸
        },
        {
          &quot;ShardId&quot;: 2,⁷
          &quot;Database&quot;: &quot;CustomerShardEU&quot;⁸
        },
        {
          &quot;ShardId&quot;: 3,⁷
          &quot;Database&quot;: &quot;CustomerShardBR&quot;⁸
        },
        {
          &quot;ShardId&quot;: 4,⁷
          &quot;Database&quot;: &quot;CustomerShardZH&quot;⁸
        }
      ]
    }
  ]
}
</code></pre>
<h3 id="annotations-1">Annotations</h3>
<p>¹ <code>PgShardSets</code> is the root JSON section for all the shard configuration metadata. It contains an array of shard sets.</p>
<p>² <code>ShardSetName</code> is a <em>required</em> key for this specific shard set. Multiple shard sets are possible and each will be identified by this key. This value must exactly match the value used in your code to invoke this shard set.</p>
<p>³ <code>Host</code> is a connection attribute. Connection attributes can appear anywhere in the hierarchy. Because it appears at the “shard set” level, all shards in the shard set will inherit this server name.</p>
<p>⁴ <code>DefaultShardId</code> this setting determins which shard is presented as the <code>ShardSet.DefaultShard</code>. This is useful for determining which shard should be actively accepting new records for this client.</p>
<p>⁵ <code>Read</code> and <code>Write</code> are peculiar, and optional, members of shard set’s “inheritance” chain, as their children are indirect. Any attributes defined in the shard set’s <code>Write</code> section apply only to write connections. Likewise, for <code>Read</code> connections. These values can be overwritten by shard or connection attributes.</p>
<p>⁶ <code>Shards</code> is an array of shard connections, one for each shard in the shard set.</p>
<p>⁷ <code>ShardId</code> is a <em>required</em> identifier for the shard. This value is essential for finding and identifying a sharded record. It cannot be duplicated within a shard set. If the type of the ShardId is a string, then this value should have quotes around it in the JSON file.</p>
<p>⁸ <code>Database</code> is a connection attribute. Because it appears at the shard level, both read connections and write connections for this shard will inherit this value.</p>
</section>
</div>

<p>This hierarchy, then, defines a server name once, to be used for the entire shard set. The read and write logins are also defined once, to be used by all read or write connections in the shard set. Each shard has a distinct database name. ArgentSea can build read and write connections to each data store without the need to configure any of this data redundantly — the login, server name, and database names are each managed only once.</p>
<p>When you save this configuration to project’s appsettings file, be sure to update the JSON to the appropriate server references.</p>
<p>You might consider moving the login password information to the UserSecrets store, which is a best practice. Simply remove the password entries from the appsettings.json hierarchy and add them to the usersecrets.json file. Ideally, the password should also be changed to a different value.</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-3">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-3_tabid-sql" role="tab" aria-controls="tabpanel_CeZOj-G++Q-3_tabid-sql" data-tab="tabid-sql" tabindex="0" aria-selected="true">SQL Server</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-3_tabid-pg" role="tab" aria-controls="tabpanel_CeZOj-G++Q-3_tabid-pg" data-tab="tabid-pg" tabindex="-1">PostgreSQL</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-3_tabid-sql" role="tabpanel" data-tab="tabid-sql">
<h3 id="user-secrets-entry">User Secrets Entry</h3>
<pre><code class="lang-json">{
  &quot;SqlShardSets&quot;: [
    {
      &quot;Write&quot;: {
        &quot;Password&quot;: &quot;Pwd567890&quot;,
      },
      &quot;Read&quot;: {
        &quot;Password&quot;: &quot;Pwd123456&quot;
      }
    }
  ]
}
</code></pre>
</section>
<section id="tabpanel_CeZOj-G++Q-3_tabid-pg" role="tabpanel" data-tab="tabid-pg" aria-hidden="true" hidden="hidden">
<h3 id="user-secrets-entry-1">User Secrets Entry</h3>
<pre><code class="lang-json">{
  &quot;PgShardSets&quot;: [
    {
      &quot;Write&quot;: {
        &quot;Password&quot;: &quot;Pwd567890&quot;,
      },
      &quot;Read&quot;: {
        &quot;Password&quot;: &quot;Pwd123456&quot;
      }
    }
  ]
}
</code></pre>
</section>
</div>

<div class="WARNING">
<h5>Warning</h5>
<p>The configuration arrays in appsettings.json and usersecrets.json will not match if they do not appear in exactly the same order. In this sample, we have only one shard set and the passwords are not in the <code>Shards</code> array, so this is not a concern.</p>
</div>
<h2 id="creating-the-models">Creating the Models</h2>
<p>The process of creating a model class was introduced in <a href="configuration.html">Quickstart 1</a>. Essentially, it simply requires adding attributes to properties, which the Mapper can then use. This QuickStart adds four new wrinkles: shard keys, object properties, list properties, and inheritance.</p>
<p>The complete code is on GitHub, at <a href="https://github.com/argentsea/quickstarts/tree/master/QuickStart2.Sql/QuickStart2.Sql">https://github.com/argentsea/quickstarts/tree/master/QuickStart2.Sql/QuickStart2.Sql</a> for SQL Server, or <a href="https://github.com/argentsea/quickstarts/tree/master/QuickStart2.Pg/QuickStart2.Pg">https://github.com/argentsea/quickstarts/tree/master/QuickStart2.Pg/QuickStart2.Pg</a> for PostgreSQL. The classes and SQL you need are located there; it is not fully reproduced here.</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-4">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-4_tabid-sql" role="tab" aria-controls="tabpanel_CeZOj-G++Q-4_tabid-sql" data-tab="tabid-sql" tabindex="0" aria-selected="true">SQL Server</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-4_tabid-pg" role="tab" aria-controls="tabpanel_CeZOj-G++Q-4_tabid-pg" data-tab="tabid-pg" tabindex="-1">PostgreSQL</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-4_tabid-sql" role="tabpanel" data-tab="tabid-sql">

<p>To use the attributes, each Model class should include a <code>using ArgentSea.Sql</code> statement.</p>
<p>Optionally, a second <code>using</code> statement can reduce the redundancy of declaring generic arguments throughout the Model class.</p>
<pre><code class="lang-csharp">using ArgentSea.Sql;
using ShardKey = ArgentSea.ShardKey&lt;byte, int&gt;;
</code></pre>
<p>Because the generic ShardId type cannot change within an application, this second <code>using</code> statement can simplify the Model code. Of course, this simplification won't work if you use different data types for the record id (integer vs bigint) in different sharded tables in the same model.</p>
<p>You can implement an equivalent practice for the <a href="/api/ArgentSea.ShardChild-3.html">ShardChild</a> object too.</p>
<p>(While it might seem even better to declare a subclass that inherits from ShardKey or ShardChild which defines the ShardId type for your entire project, unfortunately, the ShardKey and ShardChild are <em>structs</em>, so inheritance is not an option.)</p>
</section>
<section id="tabpanel_CeZOj-G++Q-4_tabid-pg" role="tabpanel" data-tab="tabid-pg" aria-hidden="true" hidden="hidden">

<p>To use the attributes, each Model class should include a <code>using ArgentSea.Pg;</code> statement.</p>
<p>Optionally, a second <code>using</code> statement can reduce the redundancy of declaring generic arguments throughout the Model class.</p>
<pre><code class="lang-csharp">using ArgentSea.Pg;
using ShardKey = ArgentSea.ShardKey&lt;short, int&gt;;
</code></pre>
<p>Because the generic ShardId type cannot change within an application, this second <code>using</code> statement can simplify the Model code. Of course, this simplification won't work if you use different data types for the record id (integer vs bigint) in different sharded tables in the same model.</p>
<p>You can implement an equivalent practice for the <a href="/api/ArgentSea.ShardChild-3.html">ShardChild</a> object too.</p>
<p>(While it might seem even better to declare a subclass that inherits from ShardKey or ShardChild which defines the ShardId type for your entire project, unfortunately, the ShardKey and ShardChild are <em>structs</em>, so inheritance is not an option.)</p>
</section>
</div>
<h2 id="advanced-model-mapping">Advanced Model Mapping</h2>
<p>The previous walthrough demonstrated mapping to standard .NET types like strings, numbers, and dates. This walkthrough illustrates mapping to objects, lists, and child classes.</p>
<h3 id="properties-with-object-types">Properties with Object Types</h3>
<p>Our data contains <strong>Location</strong> data with <em>latitude</em> and <em>longitude</em> values. Generally, these are usually managed as a value pair. Geographic functions would likely expect a single geographic <em>coordinates</em> argument, rather than the two separate values. It would be handy to map data directly to/from a coordinates class, which would be a property of the <strong>Location</strong> class.</p>
<p>That is exactly what the <code>MapToModel</code> attribute does. This attribute tells the mapper that the property is a child object that also has properties to be included in the mapping.</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-5">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-5_tabid-sql" role="tab" aria-controls="tabpanel_CeZOj-G++Q-5_tabid-sql" data-tab="tabid-sql" tabindex="0" aria-selected="true">SQL Server</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-5_tabid-pg" role="tab" aria-controls="tabpanel_CeZOj-G++Q-5_tabid-pg" data-tab="tabid-pg" tabindex="-1">PostgreSQL</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-5_tabid-sql" role="tabpanel" data-tab="tabid-sql">

<pre><code class="lang-csharp">// The coordinates class:
public class CoordinatesModel
{
    [MapToSqlFloat(&quot;Latitude&quot;)]
    public double Latitude { get; set; }

    [MapToSqlFloat(&quot;Longitude&quot;)]
    public double Longitude { get; set; }
}

// The location, which contains the coordinates class as a property:
public class LocationModel
{
    //include other properties here...

    [MapToModel]
    public CoordinatesModel Coordinates { get; set; }
}

</code></pre>
</section>
<section id="tabpanel_CeZOj-G++Q-5_tabid-pg" role="tabpanel" data-tab="tabid-pg" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">// The coordinates class:
public class CoordinatesModel
{
    [MapToPgDouble(&quot;latitude&quot;)]
    public double Latitude { get; set; }

    [MapToPgDouble(&quot;longitude&quot;)]
    public double Longitude { get; set; }
}

// The location, which contains the coordinates class as a property:
public class LocationModel
{
    //include other properties here...

    [MapToModel]
    public CoordinatesModel Coordinates { get; set; }
}

</code></pre>
</section>
</div>

<p>If the Coordinates property is null, the Mapper will instantiate an instance before setting the properties. Of course, the CoordinatesModel must have a default constructor and the property must be settable. If you want to make the property read-only, just make sure that the Coordinates object exists:</p>
<pre><code class="lang-csharp">[MapToModel]
public CoordinatesModel Coordinates { get; } = new CoordinatesModel();
</code></pre>
<h3 id="properties-with-list-types">Properties with List Types</h3>
<p>One of the most expensive activities an application can do is reach out to another server. Our high-performance application should do everything possible to minimize database server round-trips. This means getting all the data necessary to populate our <strong>Customer</strong> model in a single request. The ArgentSea Mapper can automatically handle multiple results from a single request.</p>
<p>Our <strong>Customer</strong> can have any number of <strong>Locations</strong>. Our <strong>Customer</strong> can also have any number of <strong>Contacts</strong>. Our query returns the <strong>Customer</strong>, <strong>Location</strong> <em>and</em> <strong>Contact</strong> information in a single round-trip.</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-6">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-6_tabid-sql" role="tab" aria-controls="tabpanel_CeZOj-G++Q-6_tabid-sql" data-tab="tabid-sql" tabindex="0" aria-selected="true">SQL Server</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-6_tabid-pg" role="tab" aria-controls="tabpanel_CeZOj-G++Q-6_tabid-pg" data-tab="tabid-pg" tabindex="-1">PostgreSQL</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-6_tabid-sql" role="tabpanel" data-tab="tabid-sql">

<div class="TIP">
<h5>Tip</h5>
<p>The base <strong>Customer</strong> record <em>could</em> be returned in either output parameters or in a single-row SELECT result. The first would use the Mapper’s <code>MapOutput</code> method, the other requires the <code>MapReader</code> method; both would use the data reader to handle list properties.</p>
</div>
<p>To map the multiple data reader results to the Model, we tell the Mapper the order of the results when we fetch:</p>
<pre><code class="lang-csharp">var prms = new QueryParameterCollection()
    .AddSqlIntInputParameter(&quot;@CustomerId&quot;, customerKey.RecordId)
    .CreateOutputParameters&lt;CustomerModel&gt;(_logger);
return await _shardSet[customerKey].Read.MapOutputAsync&lt;CustomerModel, LocationModel, ContactModel&gt;(Queries.CustomerGet, prms, cancellation);
</code></pre>
<p>The <code>CustomerModel</code> type in the first generic position tells the Mapper that that is the base object type. The Mapper will automatically create a new instance of the CustomerModel type and populate its properties from the query’s output parameters.</p>
<p>The <code>LocationModel</code> type in the next generic position indicates that the first data reader result contains this type. The Mapper will build a list of locations, find a property of type <code>List&lt;LocationModel&gt;</code> or <code>IList&lt;LocationModel&gt;</code>, and set the property to the list object.</p>
<p>Likewise, the third generic argument tells the Mapper that the next data reader result is a list of <strong>Contacts</strong>, which the Mapper will use to populate the <strong>Contacts</strong> property.</p>
</section>
<section id="tabpanel_CeZOj-G++Q-6_tabid-pg" role="tabpanel" data-tab="tabid-pg" aria-hidden="true" hidden="hidden">

<p>To map the multiple data reader results to the Model, we tell the Mapper the order of the results when we fetch:</p>
<pre><code class="lang-csharp">var prms = new ParameterCollection()
    .AddPgIntegerInputParameter(&quot;customerid&quot;, customerKey.RecordId);
return await _shardSet[customerKey].Read.MapReaderAsync&lt;CustomerModel, CustomerModel, LocationModel, ContactModel&gt;(Queries.CustomerGet, prms, cancellation);
</code></pre>
<div class="WARNING">
<h5>Warning</h5>
<p>Although you can also capture database results using output parameters by using <code>MapOutputAsync</code>, this is not recommended. Unlike SQL Server, there is no performance benefit with this approach and this will error if multiple SQL statements are used in the query.</p>
</div>
<p>The <code>CustomerModel</code> type in the first generic position tells the Mapper that that is the base object type. The remaining generic arguments inform the mapper of the order in the query results. Because our customer data is returned in the first result, the <code>CustomerModel</code> appears again in the second position of the generic argument list.</p>
<p>The <code>LocationModel</code> type in the third generic position indicates that the second data reader result contains this type. The Mapper will build a list of locations, find a property of type <code>List&lt;LocationModel&gt;</code> or <code>IList&lt;LocationModel&gt;</code>, and set the property to the list object.</p>
<p>Likewise, the forth generic argument tells the Mapper that the third data reader result is a list of <strong>Contacts</strong>, which the Mapper will used to populate the Contacts property.</p>
</section>
</div>

<p>Only a few lines of code are all that is required to manage this complex result.</p>
<h3 id="model-inheritance">Model Inheritance</h3>
<p>The sample application has a <code>CustomerListItem</code> Model, which contains a record key and a customer name property. The <code>CustomerModel</code> include those same values, plus some others. By inheriting from first Model, the <code>CustomerModel</code> inherits the key and an customer name, including their mapping attributes.</p>
<p>Because database queries often return subsets of entity columns, this object inheritance technique is useful in allowing the mapping attributes to be defined only once.</p>
<h3 id="the-shardkey">The ShardKey</h3>
<p>The final object type which may combine multiple data records is the <a href="/api/ArgentSea.ShardKey-2.html">ShardKey</a> and <a href="/api/ArgentSea.ShardChild-3.html">ShardChild</a> types. These are described in detail <a href="/tutorials/sharding/shardkey.md">here</a>.</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-7">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-7_tabid-sql" role="tab" aria-controls="tabpanel_CeZOj-G++Q-7_tabid-sql" data-tab="tabid-sql" tabindex="0" aria-selected="true">SQL Server</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-7_tabid-pg" role="tab" aria-controls="tabpanel_CeZOj-G++Q-7_tabid-pg" data-tab="tabid-pg" tabindex="-1">PostgreSQL</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-7_tabid-sql" role="tabpanel" data-tab="tabid-sql">

<pre><code class="lang-csharp">[MapShardKey('c', &quot;@CustomerId&quot;)]
[MapToSqlInt(&quot;@CustomerId&quot;)]
public ShardKey CustomerKey { get; set; }
</code></pre>
</section>
<section id="tabpanel_CeZOj-G++Q-7_tabid-pg" role="tabpanel" data-tab="tabid-pg" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">[MapShardKey('c', &quot;customerid&quot;)]
[MapToPgInteger(&quot;customerid&quot;)]
public ShardKey CustomerKey { get; set; }
</code></pre>
</section>
</div>

<div class="NOTE">
<h5>Note</h5>
<p>The ShardKey in this example does not specify a ShardId data mapping. Because the client knows the ShardId, ArgentSea will populate the ShardId value from this configuration data. If you provide a ShardId mapping (and include the shardid argument in the <code>MapShardKey</code> attribute), ArgentSea will understand that you want the data value instead.</p>
</div>
<h3 id="the-shardchild">The ShardChild</h3>
<p>The ShardChild object supports table compound keys in your sharded data. In this sample application, the Customer <strong>Location</strong> records are identified by a compound key including both a CustomerId and LocationId.</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-8">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-8_tabid-sql" role="tab" aria-controls="tabpanel_CeZOj-G++Q-8_tabid-sql" data-tab="tabid-sql" tabindex="0" aria-selected="true">SQL Server</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-8_tabid-pg" role="tab" aria-controls="tabpanel_CeZOj-G++Q-8_tabid-pg" data-tab="tabid-pg" tabindex="-1">PostgreSQL</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-8_tabid-sql" role="tabpanel" data-tab="tabid-sql">

<pre><code class="lang-csharp">[MapShardChild('L', &quot;CustomerId&quot;, &quot;LocationId&quot;)]
[MapToSqlInt(&quot;CustomerId&quot;)]
[MapToSqlSmallInt(&quot;LocationId&quot;)]
public ShardChild CustomerLocationKey { get; set; }
</code></pre>
</section>
<section id="tabpanel_CeZOj-G++Q-8_tabid-pg" role="tabpanel" data-tab="tabid-pg" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">[MapShardChild('L', &quot;customerid&quot;, &quot;locationid&quot;)]
[MapToPgInteger(&quot;customerid&quot;)]
[MapToPgSmallint(&quot;locationid&quot;)]
public ShardChild CustomerLocationKey { get; set; }
</code></pre>
</section>
</div>

<p>It would be possible for ArgentSea to include a “ShardGrandChild” struct, for three-column compound keys, (or even a “ShardGreatGrandChild”) but the need for this hasn’t arisen.</p>
<h2 id="loading-the-shard-service">Loading the Shard Service</h2>
<p>Loading and injecting the ArgentSea ShardSets service is similar to the Databases services explained in the last tutorial. However, because the ShardSets’ shard id type is generic, it can get tiresome to repeatedly include the generic type. We can simplify using the ShardSet type by declaring a child instance which defines the shard id type.</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-9">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-9_tabid-sql" role="tab" aria-controls="tabpanel_CeZOj-G++Q-9_tabid-sql" data-tab="tabid-sql" tabindex="0" aria-selected="true">SQL Server</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-9_tabid-pg" role="tab" aria-controls="tabpanel_CeZOj-G++Q-9_tabid-pg" data-tab="tabid-pg" tabindex="-1">PostgreSQL</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-9_tabid-sql" role="tabpanel" data-tab="tabid-sql">

<pre><code class="lang-csharp">public class ShardSets : SqlShardSets&lt;byte&gt;
{
    public ShardSets(
        IOptions&lt;SqlShardConnectionOptions&lt;byte&gt;&gt; configOptions,
        IOptions&lt;SqlGlobalPropertiesOptions&gt; globalOptions,
        ILogger&lt;ShardSets&gt; logger
    ) : base(configOptions, globalOptions, logger)
    {
        //
    }
}
</code></pre>
<p>Calling the ArgentSea <code>AddSqlService&lt;&gt;</code> (note the generic argument) extension method will load both the ArgentSea sharding and database services, <em>except</em> the ShardSet. The <code>AddSqlService</code> method does not automatically load the <code>SqlShardSets&lt;&gt;</code> service in order to to allow a locally defined, typed ShardSets collection to be loaded instead.</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddSqlServices&lt;byte&gt;(this.Configuration);
    services.AddSingleton&lt;ShardSets&gt;(); //Load locally defined service.
}
</code></pre>
<p>If you prefer to simply use the extant <code>ArgentSea.SqlShardSets</code> collection, you can load that instead:</p>
<pre><code class="lang-csharp">services.AddSingleton&lt;SqlShardSets&lt;byte&gt;&gt;(); //Load ArgentSea.ShardSets with generic parameter.
</code></pre>
</section>
<section id="tabpanel_CeZOj-G++Q-9_tabid-pg" role="tabpanel" data-tab="tabid-pg" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">public class ShardSets : PgShardSets&lt;byte&gt;
{
    public ShardSets(
        IOptions&lt;SqlShardConnectionOptions&lt;short&gt;&gt; configOptions,
        IOptions&lt;SqlGlobalPropertiesOptions&gt; globalOptions,
        ILogger&lt;ShardSets&gt; logger
    ) : base(configOptions, globalOptions, logger)
    {
        //
    }
}
</code></pre>
<p>Calling the ArgentSea <code>AddPgService&lt;&gt;</code> (note the generic argument) extension method will load both the ArgentSea sharding and database services, <em>except</em> the ShardSet. To allow a locally defined, typed ShardSets collection to be a service, you have to load it separately.</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddPgServices&lt;byte&gt;(this.Configuration);
    services.AddSingleton&lt;ShardSets&gt;(); //Load locally defined service.
}
</code></pre>
<p>If you prefer to simply use the extant <code>ArgentSea.PgShardSets</code> collection, you can load that instead:</p>
<pre><code class="lang-csharp">services.AddSingleton&lt;PgShardSets&lt;short&gt;&gt;(); //Load ArgentSea.ShardSets with generic parameter.
</code></pre>
</section>
</div>

<div class="NOTE">
<h5>Note</h5>
<p>The <code>ShardSets</code> services implicitly loads the <code>Databases</code> service also. Of course, if no databases are configured, the collection will be empty.</p>
</div>
<h2 id="queries-and-data">Queries and Data</h2>
<p>Our implementation adds two static classes which help describe our data. The first is a simple list of constants, which correspond to the “origin” parameter of <code>ShardKey</code> and <code>ShardChild</code> objects. the “Origin” helps prevent accidental use of, say, an <strong>Inventory</strong> key to delete an <strong>Order</strong> record. By using constants, you cam more explicitly distinguish the “c” used for <strong>Contact</strong> data from the “C” used for <strong>Customer</strong> data, which might otherwise be confusing.</p>
<p>The second static class consolodates query definitions, as described in the <a href="/querying/sql.md">Creating SQL Queries</a> tutorial. This serves two purposes: first, it becomes easy to determine which queries are actually used by the code (on large projects, this can be difficult). Also, the optional parameter list can limit the parameters that are set when Model attributes have more parameters than the query requires.</p>
<p>The code for these are in the <code>DataOrigins</code> and <code>Queries</code> classes respectively. The code is self explainitory.</p>
<h2 id="the-repository-pattern">The Repository Pattern</h2>
<p>Our sample code uses a <code>CustomerStore</code> class, which implements all of the actual data access logic. The theory of the repository pattern is help contain the coupling between the data layer and application logic. We could theorectically replace the data store by only changing the <code>CustomerStore</code> implementation. Because this is a web service that provides data access, the virtue of this approach is not compelling in our sample. Your milage may vary.</p>
<p>Because our web service does very little <em>except</em> read and write data, there is actually very little for the controller to do. You will find nearly all of the ArgentSea implemetation in the <code>CustomerStore</code> class.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The code in the <code>CustomerStore</code> would have been even simpler if there was no relationship between <strong>Customers</strong> and <strong>Contacts</strong>. The sample is intended to illustrate handling a challenging sharding scenario, but without this relationship the code would have been half as long.</p>
</div>
<p>This class is injected into the controller, so it need to be a registered as a service at startup.</p>
<pre><code class="lang-csharp">services.AddTransient&lt;Stores.CustomerStore&gt;();
</code></pre>
<p>The injectable <code>CustomerStore</code> class in turn uses the injected <code>ShardSets</code> service. Obtaining the injectible <code>ShardSets</code> service in your repository class is straightforward:</p>
<pre><code class="lang-csharp">public class CustomerStore
{
    private readonly ShardSets.ShardSet _shardSet;
    private readonly ILogger&lt;CustomerStore&gt; _logger;

    public CustomerStore(ShardSets shardSets, ILogger&lt;CustomerStore&gt; logger)
    {
        _shardSet = shardSets[&quot;Customers&quot;];
        _logger = logger;
    }
    ....
</code></pre>
<p>If you elected to use the ArgentSea shard sets collection instead, things are just a little more verbose:</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-10">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-10_tabid-sql" role="tab" aria-controls="tabpanel_CeZOj-G++Q-10_tabid-sql" data-tab="tabid-sql" tabindex="0" aria-selected="true">SQL Server</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-10_tabid-pg" role="tab" aria-controls="tabpanel_CeZOj-G++Q-10_tabid-pg" data-tab="tabid-pg" tabindex="-1">PostgreSQL</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-10_tabid-sql" role="tabpanel" data-tab="tabid-sql">

<pre><code class="lang-csharp">public class CustomerStore
{
    private readonly SqlShardSets&lt;byte&gt;.ShardSet _shardSet;
    private readonly ILogger&lt;CustomerStore&gt; _logger;

    public CustomerStore(SqlShardSets&lt;byte&gt; shardSets, ILogger&lt;CustomerStore&gt; logger)
    {
        _shardSet = shardSets[&quot;Customers&quot;];
        _logger = logger;
    }
    ....
</code></pre>
</section>
<section id="tabpanel_CeZOj-G++Q-10_tabid-pg" role="tabpanel" data-tab="tabid-pg" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">public class CustomerStore
{
    private readonly PgShardSets&lt;short&gt;.ShardSet _shardSet;
    private readonly ILogger&lt;CustomerStore&gt; _logger;

    public CustomerStore(PgShardSets&lt;short&gt; shardSets, ILogger&lt;CustomerStore&gt; logger)
    {
        _shardSet = shardSets[&quot;Customers&quot;];
        _logger = logger;
    }
    ....
</code></pre>
</section>
</div>

<p>Using a <code>ShardSet</code> instance, you generally simply provide a query, set parameters, and invoke a method. You can query across all shards, some shards, or within a single shard instance. Querying across all or some shards can return all results in a unified list or the first valid result.</p>
<p>The code necessary to query all shards is very simple:</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-11">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-11_tabid-sql" role="tab" aria-controls="tabpanel_CeZOj-G++Q-11_tabid-sql" data-tab="tabid-sql" tabindex="0" aria-selected="true">SQL Server</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-11_tabid-pg" role="tab" aria-controls="tabpanel_CeZOj-G++Q-11_tabid-pg" data-tab="tabid-pg" tabindex="-1">PostgreSQL</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-11_tabid-sql" role="tabpanel" data-tab="tabid-sql">

<pre><code class="lang-csharp">public async Task&lt;CustomerModel&gt; FindByLogonName(string loginName, CancellationToken cancellation)
{
    var prms = new ParameterCollection()
        .AddSqlNVarCharInputParameter(&quot;@LoginName&quot;, loginName, 255)
        .CreateOutputParameters&lt;CustomerModel&gt;(_logger);
    return await _shardSet.ReadFirst.MapOutputAsync&lt;CustomerModel, LocationModel, ContactListItem&gt;(Queries.CustomerFind, prms, cancellation);
}
</code></pre>
</section>
<section id="tabpanel_CeZOj-G++Q-11_tabid-pg" role="tabpanel" data-tab="tabid-pg" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">```csharp
public async Task&lt;CustomerModel&gt; FindByLogonName(string loginName, CancellationToken cancellation)
{
    var prms = new ParameterCollection()
        .AddPgVarcharInputParameter(&quot;loginname&quot;, loginName, 255)
        .CreateOutputParameters&lt;CustomerModel&gt;(_logger);
    return await _shardSet.ReadFirst.MapOutputAsync&lt;CustomerModel, LocationModel, ContactListItem&gt;(Queries.CustomerFind, prms, cancellation);
}
</code></pre>
</section>
</div>
<h3 id="optimizing-multi-record-saves">Optimizing Multi-Record Saves</h3>
<p>The principal means of optimizing data access is to <em>limit the number of round-trips to the database server</em>. If the need to save ten records generates ten distinct calls to the database, the solution will not be very efficient. Unfortuantely, there is no standard way of handling multi-record saves; fortunately, there are platform-specific ways of managing it.</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-12">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-12_tabid-sql" role="tab" aria-controls="tabpanel_CeZOj-G++Q-12_tabid-sql" data-tab="tabid-sql" tabindex="0" aria-selected="true">SQL Server</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-12_tabid-pg" role="tab" aria-controls="tabpanel_CeZOj-G++Q-12_tabid-pg" data-tab="tabid-pg" tabindex="-1">PostgreSQL</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-12_tabid-sql" role="tabpanel" data-tab="tabid-sql">

<p>SQL Server uses Table Valued Parameters to save multiple records. Our sample data saves a <strong>Customer</strong> with multiple <strong>Locations</strong> and multiple <strong>Contacts</strong>. These are both passed to Table Valued Parameters. This also allows the related records to be managed in a single internally-managed (low oeverhead) transaction.</p>
<p>Table Valued Parameters require a “User Defined Type”, which defines the column names and types for each row. ArgentSea offers a SQL Server-specific Mapper which converts the metadata attrributes to the correct format for this paramteter. (Like its siblings, it also uses expression trees to to compile a high-performance solution when it is initially run). In our sample implementation, the combined mapping attributes created more columns than the User Defined Type required. To solve this, we can simply provide a list or array of names; then, only those are used.</p>
<pre><code class="lang-csharp">var prms = new ParameterCollection()
    .CreateInputParameters(customer, _logger)
    .AddSqlTableValuedParameter(&quot;@Locations&quot;, customer.Locations, customerLocationTypeColumns, _logger)
    .AddSqlTableValuedParameter&lt;ContactListItem, byte, int&gt;(&quot;@Contacts&quot;, customer.Contacts, &quot;ShardId&quot;, System.Data.SqlDbType.TinyInt, &quot;RecordId&quot;, System.Data.SqlDbType.Int);
</code></pre>
<p>In this example, there are two <code>AddSqlTableValuedParameter</code> overloads, the first uses a Model and maps to the Unser Defined Type using mapping attributes; the second example maps only the key values, using the column names supplied.</p>
<p>You can learn more in the section on <a href="/querying/multirecord.md">Multi-Record Saves</a>.</p>
</section>
<section id="tabpanel_CeZOj-G++Q-12_tabid-pg" role="tabpanel" data-tab="tabid-pg" aria-hidden="true" hidden="hidden">

<p>PostgreSQL uses the COPY statement to quickly load multiple rows into tables or temporary tables. Once these records are loaded, a SQL statement can be run to process them further.</p>
<p>This process uses ArgentSea’s Batch functionality, which allows multiple steps to execute within a single open and transacted connection. In our sample, the first two steps load the <strong>Contacts</strong> and <strong>Locations</strong> data into temporary tables, then the third batch steps runs a SQL statement to save this data.</p>
<p>If the table name has a “.” schema seperater, then the target is assumed to a a standard table; without a “.” in the table name, the table is understood to be a temporary table. If the table does not exist it will be created (unless, of course, the client does not have permission to create a table). The table will have all of the coloumns defined by the model’s metadata attributes.</p>
<pre><code class="lang-csharp">var customerPrms = new ParameterCollection()
    .CreateInputParameters&lt;CustomerModel&gt;(customer, _logger);
var shardBatch = new ShardBatch&lt;short, List&lt;short&gt;&gt;()
    .Add(customer.Contacts, &quot;temp_contacts&quot;)
    .Add(customer.Locations, &quot;temp_locations&quot;)
    .Add(Queries.CustomerSave, customerPrms, &quot;contactshardid&quot;);
</code></pre>
</section>
</div>
<h2 id="using-swagger">Using Swagger</h2>
<p>when you launch the web API project, it will open to thw Swagger UI by default. If you are creating a new project, open project properties, go to the Debug tab, then change the <em>Launch browser:</em> text value to “swagger”.</p>
<p>The first GET method returns all customers, across all shards (you don't want to do this in the real world).</p>
<p>You can selected any ShardKey in the resulting list and provide that to the other GET method, which takes a ShardKey string argument. This methods returns a complex JSON result with extended customer detail.</p>
<p>You can edit the customer detail and provide that to the PATCH method to update the database values.</p>
<p>The POST method allows you to create a new customer. If successful, it returns the ShardKey of the created record. To create a new customer you can provide the following JSON:</p>
<pre><code class="lang-json">{
  &quot;name&quot;: &quot;New Customer&quot;,
  &quot;type&quot;: &quot;WalkIn&quot;,
  &quot;locations&quot;: [
    {
      &quot;type&quot;: &quot;RetailStore&quot;,
      &quot;streetAddress&quot;: &quot;123 Main Street&quot;,
      &quot;locality&quot;: &quot;Chicago&quot;,
      &quot;region&quot;: &quot;IL&quot;,
      &quot;postalCode&quot;: &quot;60612&quot;,
      &quot;iso3166&quot;: &quot;us&quot;,
      &quot;coordinates&quot;: {
        &quot;latitude&quot;: 41.867789,
        &quot;longitude&quot;: -87.675839
      }
    },
    {
      &quot;type&quot;: &quot;RetailStore&quot;,
      &quot;streetAddress&quot;: &quot;456 Oak Avenue&quot;,
      &quot;locality&quot;: &quot;Dallas&quot;,
      &quot;region&quot;: &quot;TX&quot;,
      &quot;postalCode&quot;: &quot;75211&quot;,
      &quot;iso3166&quot;: &quot;us&quot;,
      &quot;coordinates&quot;: {
        &quot;latitude&quot;: 32.730430,
        &quot;longitude&quot;: -87.675839
      }
    }
  ],
  &quot;contacts&quot;: [
    {
        &quot;origin&quot;: &quot;c&quot;,
        &quot;shardId&quot;: 1,
        &quot;recordId&quot;: 7
    },
    {
        &quot;origin&quot;: &quot;c&quot;,
        &quot;shardId&quot;: 2,
        &quot;recordId&quot;: 4
    },
    {
        &quot;origin&quot;: &quot;c&quot;,
        &quot;shardId&quot;: 1,
        &quot;recordId&quot;: 8
    }
  ]
}
</code></pre>
<p>Finally, you can DELETE a customer by providing a ShardKey.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/argentsea/docfx/blob/master/tutorials/quickstarts/sharding.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
